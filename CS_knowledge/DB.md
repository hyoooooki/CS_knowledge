# 데이터베이스

**목차**

- [회복](#recovery)
- [파일/레코드 구성](#file-record)
- [인덱스](#index)





---

## <a name ="recovery">회복</a>

**데이터 베이스 운영 중에 예상치 못한 장애로 인해 상태 이상이 생긴 것을 이전의 일관된 상태로 복원시키는 것.**



**장애유형**

- 트랜잭션 실패 : 트랜잭션을 완료하지 못한 경우.
- 시스템 손상 : DBMS, OS 등의 오류
- 디스크 고장 : 하드웨어가 손상.



**undo, redo**

- undo : 트랜잭션 로그를 이용하여 오류와 관련된 모든 변경을 취소.
- redo : 트랜잭션 로그를 이용하여 오류가 발생한 트랜잭션을 재실행하여 복구.



**로그 파일**

- 트랜잭션이 반영한 모든 데이터의 변경사항을 기록해두는 것.
- 타입 : START, INSERT, UPDATE, DELETE, COMMIT 등의 트랜잭션 연산 타입.
- START와 COMMIT이 있는 경우 REDO / START만 있고 COMMIT이 없으면 UNDO.



**회복기법**

- 로그 기반 회복 기법
  - 지연갱신 회복 기법
    - 트랜잭션의 부분 완료 상태(commit 직전)에선 변경 내용을 로그 파일에만 저장.
    - 커밋이 발생하기 전까지 데이터베이스에 기록 X
    - 중간에 장애가 발생하더라도 아직 DB에 기록되지 않았으므로 로그 폐기
  - 즉시갱신 회복 기법
    - 트랜잭션 수행 도중에도 변경 내용을 즉시 DB에 기록하고 로그 파일로 저장.
    - 만약 장애 발생시 아직 commit이 되지 않았으므로 undo필요.
- 검사적 회복 기법
  - 모든 log를 보며 복구하려면 부하가 너무 크므로 주기적으로 checkpoint를 두어 복구시에 시스템 부하를 줄인다.
  - 장애 발생시 checkpoint 이전 시점은 제외하고 이후 시점부터 복구
  - 검색된 트랜잭션중 완료된 것은 redo, 완료되지 못한 것은 undo하여 복구 진행.



## <a name="file-record">파일,레코드 구성</a>

**DB는 여러 파일로 구성되며, 파일은 여러 레코드로 구성되며, 레코드는 여러 필드로 구성된다.**



**레코드 : 필드의 집합 **

**고정 길이 레코드**

- 필드의 개수, 크기가 일정
- 구조화가 쉽다.

- delete의 오버헤드가 크다.



**가변 길이 레코드**

- 두가지 방식이 존재	
  - 필드 사이에 특별한 symbol을 넣어 구분한다.
  - 레코드 앞에 필드의 속성별 offset과 길이를 나태는 정보가 존재하고 해당 속성을 기반으로 필드의 위치를 찾아간다.



**페이지 : 레코드의 집합(파일이 페이지단위로 저장되어 있음)**

**고정 길이 슬롯**

- 두가지 방식이 존재
  - 차곡차곡 위에서 부터 slot을 쌓아가면 저장하는 packed 방식
  - slot directory를 두고 해당 위치에 레코드가 있는지 여부를 판단한다. 이를 통해 빈공간을 파악하고 필요에 의해 레코드를 저장.



**가변 길이 슬롯**

- 슬롯별로 사이즈가 다르다. 
- slot directory에 해당 슬롯의 시작 주소를 저장하고 이에 따라 레코드를 저장한다. 만약 채우다가 slot directory와 데이터가 만나면 다 채워진 것이다.
  (슬롯디렉토리는 가장 말단에 위치.)



## <a name="index"> 인덱스 </a>

- **빠른 검색을 위해서 키-값의 형태로 저장해두는 정보.**

- 데이터의 저장 성능을 희생하고 읽기 성능을 높이는 기능.



**사용 자료구조**

- B-tree, B+tree

  - 칼럼의 값을 변형하지 않고 원래의 값을 이용해서 인덱싱한다.

  - 항상 정렬된 상태를 유지하기 때문에 탐색에서는 빠르지만 삽입, 삭제, 수정 등의 작업에서는 느리다.

  - B-tree

    - 새로운 데이터가 삽입되면 리프노드에 레코드의 키값과 주소 정보가 저장되어야한다.
    - 리프 노드가 overflow되면 노드를 split해야하는데 이는 상위 브랜치 노드까지 처리 범위가 넓어져 비용이 많이 든다.
    - 모든 노드에 데이터가 저장된다. 
    - O(log N)의 검색성능
    - best case : 루트 노드에서 검색 끝

  - B+tree

    - 리프 노드에만 데이터가 저장된다.

    - 리프 노드들 끼리 연결되어 있어 순차 탐색에서 이점이 있다.

    - B트리의 경우 best case에 루트노드에서 탐색을 끝마칠 수 있지만 B+트리는 무조건 리프까지 가야한다. => O(log N)

    - 블럭사이즈를 더 많이 이용할 수 있다.

      

- hash 인덱스

  - 칼럼의 값으로 해시 함수에 입력하고 결과를 이용해  인덱싱

  - 주로 메모리기반 데이터베이스에서 주로 사용.

  - 해시 함수의 결과로 나오는 값의 범위가 넓으면 저장공간이 많이 필요하고 너무 작으면 충돌이 자주발생하여 성능이 하락된다.

  - BEST CASE : conflict가 발생하지 않는다면 O(1)의 검색 속도를 보여줄 것.

  - WORST CASE : 한 결과로 값이 쏠려 O(N)의 성능.

  - 동등 비교에는 유리하지만 range를 찾는 것에 대해서는 적합하지 않음.

  - 주로 검색을 위한 인덱스와 테이블 파티셔닝 용도로 사용.

  - 데이터 삽입,삭제,수정 등으로 데이터의 값이 변경되면 rehasing하여 index를 다시 만들어야한다.

    























reference

1. https://raisonde.tistory.com/
2. https://abydos.tistory.com/37